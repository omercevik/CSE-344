/*    CSE 344 Systems Programming    Homework 03    program.c    Omer CEVIK    161044004*/#include <stdio.h>#include <unistd.h>#include <errno.h>#include <fcntl.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <signal.h>#include <sys/wait.h>#include <gsl/gsl_poly.h>void getArguments(int argc, char *argv[], char** inputPathA, char** inputPathB, int* n);void openFiles(int* fdInputA, int* fdInputB, char* inputPathA, char* inputPathB);void parser(int** result, int** matrix, int startRow, int endRow, int startCol, int endCol);void to2DString(char* matrix, int size, int** matrix2D);void P1(int fdInputA, int fdInputB, int n, pid_t childPid[4]);void matrixMult(int** matrixAX, int** matrixBX, int** matrixAY, int** matrixBY, int size, int** matrixC);void printMatrix(int** matrix, int size);void readPipe(int pipe[2]);void writeToPipe(int pipe[2], int** writeMatrix, int size);void setMatrixC(int** matrixC, int size);void multiplicateMatrix(int** matrixC, int** transposeC, int** multMatrix, int size);void printMatrix(int** matrix, int size);void createI(int** I, int size);void findAll(int** A, int** M, int** I, int size);int sumDiagonalMatrix(int** matrix, int size);void addDiagonalMatrix(int** matrix, double value, int size);void resetMatrix(int** matrix, int size);void copyMatrix(int** matrix, int** copyOfMatrix, int size);int pipeChild1[2];int pipeChild2[2];int pipeChild3[2];int pipeChild4[2];int pipeTemp[2];static void signalHandler(int signo){    if (signo == SIGINT)    {        write(STDOUT_FILENO,"\nCTRL-C Signal is caught!\n",strlen("\nCTRL-C Signal is caught!\n"));        exit(0);    }else if (signo == SIGCHLD)    {        write(pipeTemp[1], &signo, sizeof(int));    }}int main(int argc, char *argv[]){    if (argc != 7)    {        perror("Error:\tUsage: ./program -i inputPathA.txt -j inputPathB.txt -n 8");        return -1;    }    pid_t ppid = 0;    pid_t childPid[4];    char* inputPathA = NULL;    char* inputPathB = NULL;    int n = 0, i = 0;    int fdInputA = 0;    int fdInputB = 0;    struct sigaction act;    memset (&act, 0, sizeof(act));    act.sa_handler = signalHandler;    act.sa_flags = 0;    if (sigaction(SIGINT, &act, NULL) < 0)    {        perror("Error! Sigaction CTRL C!");        exit(EXIT_FAILURE);    }    if (pipe(pipeChild1) < 0 || pipe(pipeChild2) < 0 || pipe(pipeChild3) < 0 || pipe(pipeChild4) < 0 || pipe(pipeTemp) < 0)        exit(EXIT_FAILURE);    sigset_t mask;    for (i = 0; i < 4; ++i)    {        sigfillset(&mask);        sigdelset(&mask, SIGINT);        if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)        {            perror("P1 sigprocmask() SIGCHLD");            exit(EXIT_FAILURE);        }        if((ppid = fork()) != 0)        {            if (ppid == -1)            {                perror("Parent fork can not create child processes!");                exit(EXIT_FAILURE);            }            childPid[i] = ppid;            if (i == 3)            {                /* parent */                getArguments(argc, argv, &inputPathA, &inputPathB, &n);                openFiles(&fdInputA, &fdInputB, inputPathA, inputPathB);                P1(fdInputA, fdInputB, n, childPid);                close(fdInputA);                close(fdInputB);                for (i = 0; i < 2; ++i)                {                    close(pipeChild1[i]);                    close(pipeChild2[i]);                    close(pipeChild3[i]);                    close(pipeChild4[i]);                    close(pipeTemp[i]);                }                exit(0);            }        }        else        {            /* child */            switch(i)            {                case 0: readPipe(pipeChild1);                break;                case 1: readPipe(pipeChild2);                break;                case 2: readPipe(pipeChild3);                break;                case 3: readPipe(pipeChild4);                break;                default: exit(0);                break;            }            char str[100];            sprintf(str, "Child PID : %d, Parent PID : %d\n", getpid(), getppid());            write(STDOUT_FILENO, str, strlen(str));            exit(0);        }    }    return 0;}void P1(int fdInputA, int fdInputB, int n, pid_t childPid[4]){    int i = 0;    int TWO_OVER_N = pow(2, n);    int MATRIX_SIZE = TWO_OVER_N * TWO_OVER_N;    char matrixA[MATRIX_SIZE];    char matrixB[MATRIX_SIZE];    strcpy(matrixA,"");    strcpy(matrixB,"");    int** matrix2DA = (int**)calloc(TWO_OVER_N, sizeof(int*));    int** matrix2DB = (int**)calloc(TWO_OVER_N, sizeof(int*));    int** matrixC = (int**)calloc(TWO_OVER_N, sizeof(int*));    int** I = (int**)calloc(TWO_OVER_N, sizeof(int*));    int** quarterA11 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterA12 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterA21 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterA22 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterB11 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterB12 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterB21 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    int** quarterB22 = (int**)calloc(TWO_OVER_N/2, sizeof(int*));    for (i = 0; i < TWO_OVER_N; ++i)    {        matrix2DA[i] = (int*)calloc(TWO_OVER_N, sizeof(int));        matrix2DB[i] = (int*)calloc(TWO_OVER_N, sizeof(int));        matrixC[i] = (int*)calloc(TWO_OVER_N, sizeof(int));        I[i] = (int*)calloc(TWO_OVER_N, sizeof(int));    }    for (i = 0; i < TWO_OVER_N / 2; ++i)    {        quarterA11[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterA12[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterA21[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterA22[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterB11[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterB12[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterB21[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));        quarterB22[i] = (int*)calloc(TWO_OVER_N/2, sizeof(int));    }    struct sigaction act;    memset (&act, 0, sizeof(act));    act.sa_handler = signalHandler;    act.sa_flags = 0;    if (sigaction(SIGCHLD, &act, NULL) < 0 ||        sigaction(SIGINT, &act, NULL) < 0)    {        perror("P1 Sigaction SIGCHLD or SIGINT");        exit(EXIT_FAILURE);    }    sigset_t mask;    sigfillset(&mask);    sigdelset(&mask, SIGINT);    if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)    {        perror("P1 sigprocmask() SIGINT");        exit(EXIT_FAILURE);    }    if(read(fdInputA, matrixA, MATRIX_SIZE) == MATRIX_SIZE && read(fdInputB, matrixB, MATRIX_SIZE) == MATRIX_SIZE)    {        write(STDOUT_FILENO, "A : ", 4);        write(STDOUT_FILENO, matrixA, MATRIX_SIZE);        write(STDOUT_FILENO, "\n", 1);        write(STDOUT_FILENO, "B : ", 4);        write(STDOUT_FILENO, matrixB, MATRIX_SIZE);        write(STDOUT_FILENO, "\n\n", 2);        to2DString(matrixA, TWO_OVER_N, matrix2DA);        to2DString(matrixB, TWO_OVER_N, matrix2DB);        write(STDOUT_FILENO,"Matrix A :\n",strlen("Matrix A :\n"));        printMatrix(matrix2DA, TWO_OVER_N);        write(STDOUT_FILENO,"Matrix B :\n",strlen("Matrix B :\n"));        printMatrix(matrix2DB, TWO_OVER_N);        parser(quarterA11, matrix2DA, 0, TWO_OVER_N/2, 0, TWO_OVER_N/2);        parser(quarterB11, matrix2DB, 0, TWO_OVER_N/2, 0, TWO_OVER_N/2);        parser(quarterA12, matrix2DA, 0, TWO_OVER_N/2, TWO_OVER_N/2, TWO_OVER_N);        parser(quarterB12, matrix2DB, 0, TWO_OVER_N/2, TWO_OVER_N/2, TWO_OVER_N);        parser(quarterB21, matrix2DB, TWO_OVER_N/2, TWO_OVER_N, 0, TWO_OVER_N/2);        parser(quarterA21, matrix2DA, TWO_OVER_N/2, TWO_OVER_N, 0, TWO_OVER_N/2);        parser(quarterA22, matrix2DA, TWO_OVER_N/2, TWO_OVER_N, TWO_OVER_N/2, TWO_OVER_N);        parser(quarterB22, matrix2DB, TWO_OVER_N/2, TWO_OVER_N, TWO_OVER_N/2, TWO_OVER_N);        /* Child 1 */        writeToPipe(pipeChild1, quarterA11, TWO_OVER_N/2);        writeToPipe(pipeChild1, quarterA12, TWO_OVER_N/2);        writeToPipe(pipeChild1, quarterB11, TWO_OVER_N/2);        writeToPipe(pipeChild1, quarterB21, TWO_OVER_N/2);        /* Child 2 */        writeToPipe(pipeChild2, quarterA11, TWO_OVER_N/2);        writeToPipe(pipeChild2, quarterA12, TWO_OVER_N/2);        writeToPipe(pipeChild2, quarterB12, TWO_OVER_N/2);        writeToPipe(pipeChild2, quarterB22, TWO_OVER_N/2);        /* Child 3 */        writeToPipe(pipeChild3, quarterA21, TWO_OVER_N/2);        writeToPipe(pipeChild3, quarterA22, TWO_OVER_N/2);        writeToPipe(pipeChild3, quarterB11, TWO_OVER_N/2);        writeToPipe(pipeChild3, quarterB21, TWO_OVER_N/2);        /* Child 4 */        writeToPipe(pipeChild4, quarterA21, TWO_OVER_N/2);        writeToPipe(pipeChild4, quarterA22, TWO_OVER_N/2);        writeToPipe(pipeChild4, quarterB12, TWO_OVER_N/2);        writeToPipe(pipeChild4, quarterB22, TWO_OVER_N/2);        sigfillset(&mask);        sigdelset(&mask, SIGINT);        if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)        {            perror("P1 sigprocmask() SIGINT");            exit(EXIT_FAILURE);        }        setMatrixC(matrixC, TWO_OVER_N/2);        sigfillset(&mask);        sigdelset(&mask, SIGINT);        if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)        {            perror("P1 sigprocmask() SIGINT");            exit(EXIT_FAILURE);        }        write(STDOUT_FILENO,"Matrix C : \n",strlen("Matrix C : \n"));        printMatrix(matrixC, TWO_OVER_N);        createI(I, TWO_OVER_N);        resetMatrix(matrix2DA, TWO_OVER_N);        findAll(matrixC, matrix2DA, I, TWO_OVER_N);    }    else        write(STDOUT_FILENO, "Error! There is no sufficient input to read!\n", strlen("Error! There is no sufficient input to read!\n"));    for (i = 0; i < TWO_OVER_N; ++i)    {        free(matrix2DA[i]);        free(matrix2DB[i]);        free(matrixC[i]);        free(I[i]);    }    for (i = 0; i < TWO_OVER_N/2; ++i)    {        free(quarterA11[i]);        free(quarterA12[i]);        free(quarterA21[i]);        free(quarterA22[i]);        free(quarterB11[i]);        free(quarterB12[i]);        free(quarterB21[i]);        free(quarterB22[i]);    }    free(matrix2DA);    free(matrix2DB);    free(matrixC);    free(I);    free(quarterA11);    free(quarterA12);    free(quarterA21);    free(quarterA22);    free(quarterB11);    free(quarterB12);    free(quarterB21);    free(quarterB22);}void readPipe(int pipe[2]){    struct sigaction act;    memset (&act, 0, sizeof(act));    act.sa_handler = signalHandler;    act.sa_flags = 0;    if (sigaction(SIGINT, &act, NULL) < 0)    {        perror("P1 Sigaction SIGINT");        exit(EXIT_FAILURE);    }    sigset_t mask;    sigfillset(&mask);    sigdelset(&mask, SIGINT);    if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)    {        perror("P1 sigprocmask() SIGINT");        exit(EXIT_FAILURE);    }    int** readMatrixAX = NULL;    int** readMatrixAY = NULL;    int** readMatrixBX = NULL;    int** readMatrixBY = NULL;    int** matrixC = NULL;    int matrixSize = 0, i = 0, j = 0;    read(pipe[0], &matrixSize, sizeof(int));    readMatrixAX = (int**)calloc(matrixSize, sizeof(int*));    readMatrixAY = (int**)calloc(matrixSize, sizeof(int*));    readMatrixBX = (int**)calloc(matrixSize, sizeof(int*));    readMatrixBY = (int**)calloc(matrixSize, sizeof(int*));    matrixC = (int**)calloc(matrixSize, sizeof(int*));    for (i = 0; i < matrixSize; ++i)    {        readMatrixAX[i] = (int*)calloc(matrixSize, sizeof(int));        readMatrixAY[i] = (int*)calloc(matrixSize, sizeof(int));        readMatrixBX[i] = (int*)calloc(matrixSize, sizeof(int));        readMatrixBY[i] = (int*)calloc(matrixSize, sizeof(int));        matrixC[i] = (int*)calloc(matrixSize, sizeof(int));    }    for (i = 0; i < matrixSize; ++i)        for (j = 0; j < matrixSize; ++j)            read(pipe[0], &readMatrixAX[i][j], sizeof(int));    read(pipe[0], &matrixSize, sizeof(int));    for (i = 0; i < matrixSize; ++i)        for (j = 0; j < matrixSize; ++j)            read(pipe[0], &readMatrixAY[i][j], sizeof(int));    read(pipe[0], &matrixSize, sizeof(int));    for (i = 0; i < matrixSize; ++i)        for (j = 0; j < matrixSize; ++j)            read(pipe[0], &readMatrixBX[i][j], sizeof(int));    read(pipe[0], &matrixSize, sizeof(int));    for (i = 0; i < matrixSize; ++i)        for (j = 0; j < matrixSize; ++j)            read(pipe[0], &readMatrixBY[i][j], sizeof(int));    matrixMult(readMatrixAX, readMatrixBX, readMatrixAY, readMatrixBY, matrixSize, matrixC);    for (i = 0; i < matrixSize; ++i)        for (j = 0; j < matrixSize; ++j)            write(pipe[1],&matrixC[i][j],sizeof(int));    for (i = 0; i < matrixSize; ++i)    {        free(readMatrixAX[i]);        free(readMatrixAY[i]);        free(readMatrixBX[i]);        free(readMatrixBY[i]);        free(matrixC[i]);    }    free(readMatrixAX);    free(readMatrixAY);    free(readMatrixBX);    free(readMatrixBY);    free(matrixC);    write(pipeTemp[1], &i, sizeof(int));    kill(getppid(), SIGCHLD);}void writeToPipe(int pipe[2], int** writeMatrix, int size){    int i = 0, j = 0;    write(pipe[1], &size, sizeof(int));    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)            write(pipe[1], &writeMatrix[i][j], sizeof(int));}void setMatrixC(int** matrixC, int size){    int i = 0, j = 0, k = 0, l = 0, temp = 0;    read(pipeTemp[0], &temp, sizeof(int));    read(pipeTemp[0], &temp, sizeof(int));    read(pipeTemp[0], &temp, sizeof(int));    read(pipeTemp[0], &temp, sizeof(int));    for (i = 0; i < size; ++i, ++k, l = 0)    {        for (j = 0; j < size; ++j, ++l)            read(pipeChild1[0], &matrixC[k][l], sizeof(int));        for (j = 0; j < size; ++j, ++l)            read(pipeChild2[0], &matrixC[k][l], sizeof(int));    }    for (i = 0; i < size; ++i, ++k, l = 0)    {        for (j = 0; j < size; ++j, ++l)            read(pipeChild3[0], &matrixC[k][l], sizeof(int));        for (j = 0; j < size; ++j, ++l)            read(pipeChild4[0], &matrixC[k][l], sizeof(int));    }}void matrixMult(int** matrixAX, int** matrixBX, int** matrixAY, int** matrixBY, int size, int** matrixC){    int i = 0, j = 0, k = 0, sum = 0;    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)        {            for (k = 0; k < size; ++k)                sum += matrixAX[i][k] * matrixBX[k][j] + matrixAY[i][k] * matrixBY[k][j];            matrixC[i][j] = sum;            sum = 0;        }}void printMatrix(int** matrix, int size){    int i = 0, j = 0;    char printString[25];    strcpy(printString,"");    for (i = 0; i < size; ++i)    {        for (j = 0; j < size; ++j)        {            sprintf(printString,"%d ",matrix[i][j] );            write(STDOUT_FILENO, printString, strlen(printString));        }        write(STDOUT_FILENO,"\n",1);    }    write(STDOUT_FILENO,"\n",1);}void parser(int** result, int** matrix, int startRow, int endRow, int startCol, int endCol){    int i = 0, j = 0, k = 0, l = 0;    for (i = startRow; i < endRow; ++i, ++k)        for (j = startCol, l = 0; j < endCol; ++j, ++l)            result[k][l] = matrix[i][j];}void to2DString(char* matrix, int size, int** matrix2D){    int i = 0, j = 0, counter = 0;    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)            matrix2D[i][j] = matrix[counter++];}void getArguments(int argc, char *argv[], char** inputPathA, char** inputPathB, int* n){    int opt = 0;    while((opt = getopt(argc, argv, "i:j:n:")) != -1)    {        if (opt == 'i')            *inputPathA = optarg;        else if (opt == 'j')            *inputPathB = optarg;        else if (opt == 'n')            sscanf(optarg,"%d",n);        else        {            perror("Unknown option!");            exit(EXIT_FAILURE);        }    }}void openFiles(int* fdInputA, int* fdInputB, char* inputPathA, char* inputPathB){    *fdInputA = open(inputPathA, O_RDONLY, 0666);    *fdInputB = open(inputPathB, O_RDONLY, 0666);    if (*fdInputA == -1)    {        char str[256];        sprintf(str,"Input A Open Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open output file!");        close(*fdInputB);        exit(EXIT_FAILURE);    }    if (*fdInputB == -1)    {        char str[256];        sprintf(str,"Input B Open Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open input file!");        close(*fdInputA);        exit(EXIT_FAILURE);    }}void addDiagonalMatrix(int** matrix, double value, int size){    int i = 0;    for (i = 0; i < size; ++i)            matrix[i][i] += value;}int sumDiagonalMatrix(int** matrix, int size){    int sum = 0, i = 0;    for (i = 0; i < size; ++i)            sum += matrix[i][i];    return sum;}void createI(int** I, int size){    int i = 0;    for (i = 0; i < size; ++i)            I[i][i] = 1;}void resetMatrix(int** matrix, int size){    int i = 0, j = 0;    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)            matrix[i][j] = 0;}void copyMatrix(int** matrix, int** copyOfMatrix, int size){    int i = 0, j = 0;    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)            matrix[i][j] = copyOfMatrix[i][j];}void multiplicateMatrix(int** matrixC, int** transposeC, int** multMatrix, int size){    int i = 0, j = 0, k = 0, sum = 0;    for (i = 0; i < size; ++i)        for (j = 0; j < size; ++j)        {            for (k = 0; k < size; ++k)                sum += matrixC[i][k] * transposeC[k][j];            multMatrix[i][j] = sum;            sum = 0;        }}void findAll(int** A, int** M, int** I, int size){    int i = 0;    char printString[256];    double c[size+1], z[10];    int** copyOfM = (int**)calloc(size, sizeof(int*));    strcpy(printString,"");    for (i = 0; i < size; ++i)        copyOfM[i] = (int*)calloc(size, sizeof(int));    c[size] = 1;    multiplicateMatrix(A, I, M, size);    c[size - 1] = -sumDiagonalMatrix(M, size);    addDiagonalMatrix(M, c[size - 1], size);    for (i = size - 2; -1 < i; --i)    {        multiplicateMatrix(A, M, copyOfM, size);        c[i] = (double)-sumDiagonalMatrix(copyOfM, size) / (size - i);        addDiagonalMatrix(copyOfM, c[i], size);        copyMatrix(M, copyOfM, size);    }    gsl_poly_complex_workspace * w = gsl_poly_complex_workspace_alloc(size+1);    gsl_poly_complex_solve(c, size+1, w, z);    gsl_poly_complex_workspace_free(w);    for (i = 0; i < size; ++i)    {        sprintf(printString,"Singular value [%d] = %.3f + %.3fi\n",i, sqrt(z[2*i]), sqrt(z[2*i + 1]));        write(STDOUT_FILENO,printString,strlen(printString));    }    for (i = 0; i < size; ++i)        free(copyOfM[i]);    free(copyOfM);}