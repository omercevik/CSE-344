/*    CSE 344 Systems Programming    Homework 02    program.c    Omer CEVIK    161044004*/#include <stdio.h>#include <unistd.h>#include <errno.h>#include <fcntl.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <signal.h>#include <sys/wait.h>#define MAX_SIZE 50000int fdInput;int fdtemp;int fdtempWrite;int fdOutput;char temp[25] = "mkstempXXXXXX";char* inputPath = NULL;static void P1Handler(int signo){    if (signo == SIGTERM)    {        close(fdInput);        close(fdOutput);        close(fdtemp);        close(fdtempWrite);        unlink(temp);        remove(inputPath);    }}static void P2Handler(int signo){    if (signo == SIGTERM)    {        close(fdInput);        close(fdOutput);        close(fdtemp);        close(fdtempWrite);        unlink(temp);        remove(inputPath);    }}struct coord{    int x[10];    int y[10];};void getArguments(int argc, char *argv[], char** inputPath, char** outputPath);void P1(pid_t childPid);void parseToArrays(struct coord* coords, char* input);void leastSquaresMethod(struct coord coords, double* a, double* b);void P2();double calculateMAE(struct coord coords);double calculateMSE(struct coord coords);double calculateRMSE(struct coord coords);void calculateStandartDeviation(double errors[3][MAX_SIZE], double errorsMeans[3], int size, double resultsStdDev[3]);void calculateMean(double errors[3][MAX_SIZE], int size, double resultsMean[3]);int main(int argc, char *argv[]){    if (argc != 5)    {        perror("Error:\tUsage: ./program -i inputPath -o outputPath");        return 1;    }    char* outputPath = NULL;    getArguments(argc, argv, &inputPath, &outputPath);    fdInput = open(inputPath, O_RDONLY, 0666);    fdtemp = mkstemp(temp);    fdtempWrite = open(temp, O_RDWR, 0666);    fdOutput = open(outputPath, O_WRONLY | O_CREAT, 0666);    if (fdOutput == -1)    {        char str[256];        sprintf(str,"P2 Output Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open output file!");        close(fdtemp);        exit(EXIT_FAILURE);    }    if (fdtempWrite == -1)    {        char str[256];        sprintf(str,"P2 Temp Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open mkstemp file!");        close(fdOutput);        exit(EXIT_FAILURE);    }    if (fdInput == -1)    {        char str[256];        sprintf(str,"P1 Input Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open input file!");        close(fdtemp);        exit(EXIT_FAILURE);    }    if (fdtemp == -1)    {        char str[256];        sprintf(str,"P1 Temp Error Number %d\n", errno);        write(STDOUT_FILENO, str, strlen(str));        perror("Program can not open mkstemp file!");        close(fdInput);        exit(EXIT_FAILURE);    }    pid_t childPid = fork();    if (childPid != 0)    {        P1(childPid);    }    else    {        P2();        unlink(temp);        remove(inputPath);    }    int status;    waitpid(childPid, &status, 0);    return 0;}void P1(pid_t childPid){    struct sigaction act;    memset (&act, 0, sizeof(act));    act.sa_handler = &P1Handler;    if (sigaction(SIGUSR1, &act, NULL) == -1 ||        sigaction(SIGTERM, &act, NULL) == -1)    {        perror("P1 Sigaction SIGUSR1");        exit(EXIT_FAILURE);    }    char readInput[21] = "";    char str[256];    char newLine;    int i = 0, readRes = 0, totalBytes = 0;    double a = 0.0, b = 0.0;    struct coord coords;    sigset_t mask;    while( (readRes = read(fdInput, readInput, 20)) == 20 )    {        sigfillset(&mask);        if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)        {            perror("P1 sigprocmask() SIGUSR1");            exit(EXIT_FAILURE);        }        totalBytes += readRes;        parseToArrays(&coords, readInput);        leastSquaresMethod(coords, &a, &b);        for (i = 0; i < 10; ++i)        {            sprintf(str,"(%d, %d), ", coords.x[i], coords.y[i]);            write(fdtemp, str, strlen(str));            strcpy(str,"");        }        sprintf(str,"%.3fx+%.3f\n",a,b);        write(fdtemp, str, strlen(str));        strcpy(str,"");        if (read(fdInput, &newLine, sizeof(char)) != 1)        {            readRes = 0;            break;        }        kill(childPid, SIGUSR2);        sigfillset(&mask);        sigdelset(&mask, SIGUSR1);        if (sigprocmask(SIG_SETMASK, &mask, NULL) < 0)        {            perror("P1 sigprocmask() SIGUSR1");            exit(EXIT_FAILURE);        }        sigsuspend(&mask);    }    sprintf(str,"P1 Total read bytes : %d\nP1 Total read lines : %d\nP1 Signals : SIGUSR1, SIGUSR2, SIGTERM\n", totalBytes, totalBytes / 20);    write(STDOUT_FILENO, str, strlen(str));    close(fdtemp);    close(fdInput);    kill(childPid, SIGUSR2);}void P2(){    sigset_t set;    sigfillset(&set);    sigdelset(&set, SIGUSR2);    struct sigaction act;    memset (&act,0 , sizeof(act));    act.sa_handler = &P2Handler;    if (sigaction(SIGTERM, &act, NULL) < 0 ||        sigaction(SIGUSR2, &act, NULL) < 0 )    {        perror ("Sigaction P2 SIGTERM or SIGUSR2.");        exit(0);    }    if (sigprocmask(SIG_SETMASK, &set, NULL) < 0)    {        perror("P2 sigprocmask()");        exit(EXIT_FAILURE);    }    char c, line[256];    int i = 0, first = 0, errorIndex = 0;    double errors[3][MAX_SIZE];    sigsuspend(&set);    while(read(fdtempWrite, &c, sizeof(char)) == 1)    {        if (c == '\n')        {            line[i] = '\0';            i = 0;            struct coord coords;            int j = 0, commaCounter = 0;            char coordString[25];            while(line[i] != '\0')            {                if (line[i] == ')')                {                    if (++commaCounter == 11)                        break;                    coordString[j] = '\0';                    char openP, closeP, comma, space;                    int x, y;                    sscanf(coordString,"%c%d%c%c%d%c",&openP, &x, &comma, &space, &y, &closeP);                    coords.x[commaCounter-1] = x;                    coords.y[commaCounter-1] = y;                    j = 0;                    i += 3;                    continue;                }                coordString[j++] = line[i];                ++i;            }            if (++first == 1)                lseek(fdtempWrite, 0, SEEK_SET);            else                lseek(fdtempWrite, -strlen(line)-1, SEEK_CUR);            i = 0;            while(i++ < strlen(line))                write(fdtempWrite," ",1);            write(fdtempWrite,"\n",1);            double a, b;            char xc, plus;            sscanf(&line[i],"%lf%c%c%lf",&a, &xc, &plus, &b);            sigfillset(&set);            if (sigprocmask(SIG_SETMASK, &set, NULL) < 0)            {                perror("P2 sigprocmask()");                exit(EXIT_FAILURE);            }            errors[0][errorIndex] = calculateMAE(coords);            errors[1][errorIndex] = calculateMSE(coords);            errors[2][errorIndex] = calculateRMSE(coords);            write(fdOutput, line, strlen(line));            sprintf(coordString, ", %.3f", errors[0][errorIndex]);            write(fdOutput, coordString, strlen(coordString));            sprintf(coordString, ", %.3f", errors[1][errorIndex]);            write(fdOutput, coordString, strlen(coordString));            sprintf(coordString, ", %.3f\n", errors[2][errorIndex]);            write(fdOutput, coordString, strlen(coordString));            ++errorIndex;            i = 0;            sigfillset(&set);            sigdelset(&set, SIGUSR2);            if (sigprocmask(SIG_SETMASK, &set, NULL) < 0)            {                perror("P2 sigprocmask()");                exit(EXIT_FAILURE);            }            kill(getppid(), SIGUSR1);            sigsuspend(&set);            continue;        }        line[i++] = c;    }    close(fdtempWrite);    close(fdOutput);    sprintf(line,"\nINDEX\t\tMAE\t\tMSE\t\tRMSE\n");    write(STDOUT_FILENO, line, strlen(line));    sprintf(line,"---------------------------------------------------------\n");    write(STDOUT_FILENO, line, strlen(line));    for (i = 0; i < errorIndex; ++i)    {        sprintf(line,"[%d]\t\t%.3f\t\t%.3f\t\t%.3f\n", i, errors[0][i], errors[1][i], errors[2][i]);        write(STDOUT_FILENO, line, strlen(line));    }    double errorsMeans[3], errorsStdDev[3];    calculateMean(errors, errorIndex, errorsMeans);    sprintf(line,"\nMAE Errors Mean : %.3f\n", errorsMeans[0]);    write(STDOUT_FILENO, line, strlen(line));    sprintf(line,"MSE Errors Mean : %.3f\n", errorsMeans[1]);    write(STDOUT_FILENO, line, strlen(line));    sprintf(line,"RMSE Errors Mean : %.3f\n", errorsMeans[2]);    write(STDOUT_FILENO, line, strlen(line));    calculateStandartDeviation(errors, errorsMeans, errorIndex, errorsStdDev);    sprintf(line,"\nMAE Errors Standart Deviation : %.3f\n", errorsStdDev[0]);    write(STDOUT_FILENO, line, strlen(line));    sprintf(line,"MSE Errors Standart Deviation : %.3f\n", errorsStdDev[1]);    write(STDOUT_FILENO, line, strlen(line));    sprintf(line,"RMSE Errors Standart Deviation : %.3f\n", errorsStdDev[2]);    write(STDOUT_FILENO, line, strlen(line));}void calculateStandartDeviation(double errors[3][MAX_SIZE], double errorsMeans[3], int size, double resultsStdDev[3]){    resultsStdDev[0] = 0.0;    resultsStdDev[1] = 0.0;    resultsStdDev[2] = 0.0;    int i;    for (i = 0; i < size; ++i)    {        resultsStdDev[0] += pow(errors[0][i] - errorsMeans[0], 2);        resultsStdDev[1] += pow(errors[1][i] - errorsMeans[1], 2);        resultsStdDev[2] += pow(errors[2][i] - errorsMeans[2], 2);    }    resultsStdDev[0] = sqrt(resultsStdDev[0] / size);    resultsStdDev[1] = sqrt(resultsStdDev[1] / size);    resultsStdDev[2] = sqrt(resultsStdDev[2] / size);}void calculateMean(double errors[3][MAX_SIZE], int size, double resultsMean[3]){    resultsMean[0] = 0.0;    resultsMean[1] = 0.0;    resultsMean[2] = 0.0;    int i;    for (i = 0; i < size; ++i)    {        resultsMean[0] += errors[0][i];        resultsMean[1] += errors[1][i];        resultsMean[2] += errors[2][i];    }    resultsMean[0] /= size;    resultsMean[1] /= size;    resultsMean[2] /= size;}double calculateMAE(struct coord coords){    double errorResult = 0.0;    int i;    for (i = 0; i < 10; ++i)        errorResult += abs(coords.y[i] - coords.x[i]);    return errorResult / 10;}double calculateMSE(struct coord coords){    double errorResult = 0.0;    int i;    double a, b;    leastSquaresMethod(coords, &a, &b);    for (i = 0; i < 10; ++i)    {        double newY = a * coords.x[i] + b;        errorResult += pow(coords.y[i] - newY, 2);    }    return errorResult / 10;}double calculateRMSE(struct coord coords){    return sqrt(calculateMSE(coords));}void getArguments(int argc, char *argv[], char** inputPath, char** outputPath){    int opt = 0;    while((opt = getopt(argc, argv, "i:o:")) != -1)    {        switch(opt)        {            case 'i':                *inputPath = optarg;                break;            case 'o':                *outputPath = optarg;                break;            default:                perror("Unknown option!\n");                break;        }    }}void leastSquaresMethod(struct coord coords, double* a, double* b){    int i = 0, N = 10;    double xy = 0.0, xsquare = 0.0, xtotal = 0.0, ytotal = 0.0;    for (i = 0; i < 10; ++i)    {        xsquare += coords.x[i] * coords.x[i];        xtotal += coords.x[i];        ytotal += coords.y[i];        xy += coords.x[i] * coords.y[i];    }    *a = (N * xy - xtotal * ytotal) / ( N * xsquare - xtotal * xtotal);    *b = (ytotal - (*a) * xtotal) / N;}void parseToArrays(struct coord* coords, char* input){    int i = 0, j = 0;    while(*input)    {        coords->x[i] = *input;        ++input;        coords->y[i] = *input;        ++input;        ++i;    }}