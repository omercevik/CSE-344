/*    CSE 344 Systems Programming    Midterm Project    program.c    Omer CEVIK    161044004*/#include "main.h"Semaphore *semaphore;static void signalHandler(int signo){    if (signo == SIGINT)    {        write(STDOUT_FILENO, "\nCTRL-C is caught!\n", strlen("\nCTRL-C is caught!\n"));        sem_destroy(&semaphore->semCook);        sem_destroy(&semaphore->semSupplier);        sem_destroy(&semaphore->semStudent);        sem_destroy(&semaphore->semCookStudent);        if (munmap(semaphore, sizeof(*semaphore)) < 0)        {            perror("Error: munmap semaphore!");            exit(EXIT_FAILURE);        }        exit(0);    }}int main(int argc, char *argv[]){    char str[1024];    strcpy(str,"");    if (argc != 13)    {        sprintf(str,"Error:\tUsage: ./program -N 3 -M 12 -T 5 -S 4 -L 13 -F filePath");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    struct sigaction act;    memset (&act,0 , sizeof(act));    act.sa_flags = 0;    act.sa_handler = &signalHandler;    if (sigaction(SIGINT, &act, NULL) < 0)    {        sprintf(str,"Error: Sigaction SIGINT!");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    int Ncooks = 0, Mstudents = 0, Ttables = 0, counterSizeS = 0, L = 0, kitchenSizeK = 0, P = 0, C = 0, D = 0, i = 0;    char* filePath = NULL;    pid_t pid;    getArguments(argc, argv, &Ncooks, &Mstudents, &Ttables, &counterSizeS, &L, &filePath);    kitchenSizeK = checkValuesForK(Ncooks,Mstudents,Ttables,counterSizeS,L);    // Write to counter    writeToSharedMemory("/sharedCounter",0,0,0);    // Write to kitchen    writeToSharedMemory("/sharedKitchen",0,0,0);    // Write to kitchen    writeToSharedMemory("/sharedTables",Ttables,Ttables,Ttables);    P = L * Mstudents;    C = L * Mstudents;    D = L * Mstudents;    // Creates random P C D values into the filePath.    //createRandomInputFile(filePath,P+C+D);    srand(time(0));    semaphore = (Semaphore *)mmap(0, sizeof(*semaphore), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);    if (sem_init(&semaphore->semSupplier,1,0) == -1)    {        sprintf(str, "Cannot create Supplier semaphore!..\n");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    if (sem_init(&semaphore->semCook,1,1) == -1)    {        sprintf(str, "Cannot create Cook semaphore!..\n");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    if (sem_init(&semaphore->semStudent,1,0) == -1)    {        sprintf(str, "Cannot create Student semaphore!..\n");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    if (sem_init(&semaphore->semCookStudent,1,1) == -1)    {        sprintf(str, "Cannot create Student semaphore!..\n");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    for (i = 0; i < Mstudents; ++i)    {        pid = fork();        if(pid == 0)            student(i, L);    }    if (pid > 0 && i == Mstudents)    {        for(i = 0; i < Ncooks; ++i)        {            pid = fork();            if(pid == 0)                cook(i, P+C+D);        }        if(pid > 0 && i == Ncooks)        {            // Supplier            supplier(P,C,D,filePath,Ncooks);        }    }    while(wait(NULL) > 0);    sem_destroy(&semaphore->semCook);    sem_destroy(&semaphore->semSupplier);    sem_destroy(&semaphore->semStudent);    sem_destroy(&semaphore->semCookStudent);    if (munmap(semaphore, sizeof(*semaphore)) < 0)    {        perror("Error: munmap semaphore!");        exit(EXIT_FAILURE);    }    return 0;}void getArguments(int argc, char *argv[], int* Ncooks, int* Mstudents, int* Ttables, int* counterSizeS, int* L, char** filePath){    int opt = 0;    while((opt = getopt(argc, argv, "N:M:T:S:L:F:")) != -1)    {        switch(opt)        {            case 'N':                sscanf(optarg,"%d",Ncooks);                break;            case 'M':                sscanf(optarg,"%d",Mstudents);                break;            case 'T':                sscanf(optarg,"%d",Ttables);                break;            case 'S':                sscanf(optarg,"%d",counterSizeS);                break;            case 'L':                sscanf(optarg,"%d",L);                break;            case 'F':                *filePath = optarg;                break;            default:                perror("Unknown option!\n");                break;        }    }}int checkValuesForK(int Ncooks, int Mstudents, int Ttables, int counterSizeS, int L){    if (Mstudents > Ncooks && Ncooks > 2 && counterSizeS > 3 && Mstudents > Ttables && Ttables >= 1 && L >= 3)        return 2*L*Mstudents+1;    perror("K is not created!");    exit(EXIT_FAILURE);}