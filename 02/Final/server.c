/*    CSE 344 Systems Programming    Final Project    server.c    Omer CEVIK    161044004*/#include "main.h"struct Graph* graph;struct DataBase* db;struct queue* socketFdQueue;Semaphore* semaphore;pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;int logFd = 0;int busyThreadCounter = 0;int socketClose = 0;int* dbPath;int s = 0, x = 0;static void signalHandler(int signo){    if (signo == SIGINT)    {        char str[1024] = "";        sprintf(str,"\nTermination signal received, waiting for ongoing threads to complete.\n");        write(STDOUT_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        sprintf(str,"All threads have terminated, server shutting down.\n");        write(STDOUT_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        destroySemaphores();        close(socketClose);        close(logFd);        freeGraph(graph);        freeDataBase(&db);        pthread_mutex_destroy(&lock);        free(dbPath);        free(socketFdQueue);        exit(0);    }}int main(int argc, char *argv[]){    char str[1024] = "";    if (argc != 11)    {        sprintf(str,"Error:\tUsage: ./server -i pathToFile -p PORT -o pathToLogFile -s 4 -x 24");        write(STDERR_FILENO, str, strlen(str));        exit(EXIT_FAILURE);    }    makeDaemon(01);    char *filePath = NULL, *logFile = NULL;    int portNumber = 0;    struct sigaction act;    memset (&act,0 , sizeof(act));    act.sa_flags = 0;    act.sa_handler = &signalHandler;    if (sigaction(SIGINT, &act, NULL) < 0)    {        sprintf(str,"Error: Sigaction SIGINT!\n");        write(STDERR_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        exit(EXIT_FAILURE);    }    getArgumentsServer(argc, argv, &filePath, &portNumber, &logFile);    logFd = open(logFile, O_WRONLY | O_CREAT, 0666);    if (logFd == -1)    {        char str[256] = "";        sprintf(str,"Log Open Error Number %d\n", errno);        write(STDERR_FILENO, str, strlen(str));        perror("Program can not open log file!");        exit(EXIT_FAILURE);    }    initSemaphores();    socketFdQueue = createQueue();    readFile(filePath);    dbPath = (int*)calloc(SIZE, sizeof(int));    // Server Socket Connection    int sockfd = 0, connfd = 0;    socklen_t len;    struct sockaddr_in servaddr, cli;    sockfd = socket(AF_INET, SOCK_STREAM, 0);    if (sockfd == -1)    {        sprintf(str,"Error: Socket creation failed!\n");        write(STDERR_FILENO,str,strlen(str));        exit(EXIT_FAILURE);    }    else    {        sprintf(str,"Socket successfully created!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));    }    bzero(&servaddr, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(portNumber);    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0)    {        sprintf(str,"Error: Socket bind failed!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));        exit(EXIT_FAILURE);    }    else    {        sprintf(str,"Socket successfully binded!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));    }    if ((listen(sockfd, 16)) != 0)    {        sprintf(str,"Error: Listen failed!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));        exit(EXIT_FAILURE);    }    else    {        sprintf(str,"Server listening!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));    }    len = sizeof(cli);    pthread_t additionalT;    if(pthread_create(&additionalT, NULL, &additionalThread, NULL))    {        sprintf(str, "Error: Creating thread!\n");        write(STDERR_FILENO,str,strlen(str));        write(logFd,str,strlen(str));        exit(EXIT_FAILURE);    }    socketClose = sockfd;    for(;;)    {        connfd = accept(sockfd, (SA*)&cli, &len);        if (connfd < 0)        {            sprintf(str,"No thread is available! Waiting for one.\n");            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));            while( 0 > (connfd = accept(sockfd, (SA*)&cli, &len)));            enqueue(socketFdQueue, connfd);            sem_post(&semaphore->semServer);            sprintf(str,"Server acccept the client!\n");            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));        }        else        {            enqueue(socketFdQueue, connfd);            sem_post(&semaphore->semServer);            sprintf(str,"Server acccept the client!\n");            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));        }    }    free(dbPath);    free(socketFdQueue);    destroySemaphores();    close(sockfd);    close(logFd);    freeDataBase(&db);    freeGraph(graph);    pthread_mutex_destroy(&lock);    return 0;}void* additionalThread(void* ptr){    char str[1024] = "";    int idThreads[x], i = 0, j = 0;    double maxBusy = 0.0;    pthread_t threadPool[x];    for (i = 0; i < x; ++i)        idThreads[i] = i;    createDataBase(&db, graph->V);    for (i = 0; i < s; ++i, ++j)        if(pthread_create(&threadPool[i], NULL, &serverThread, (void*)&idThreads[j]))        {            sprintf(str, "Error: Creating thread!\n");            write(STDERR_FILENO,str,strlen(str));            write(logFd,str,strlen(str));            exit(EXIT_FAILURE);        }    clock_t t = clock();    sprintf(str,"Timestamp(%ld) A pool of %d threads has been created\n",t,s);    write(STDOUT_FILENO,str,strlen(str));    write(logFd,str,strlen(str));    for (;;)    {        sem_wait(&semaphore->semServer);        if (busyThreadCounter > 0)            maxBusy = busyThreadCounter * 1.0 / s;        if(maxBusy >= 0.75)        {            int currentThreadSize = s;            s += s * 0.25;            if (s > x)                s = x;            t = clock();            sprintf(str,"Timestamp(%ld) System load 75%%, pool extended to %d threads\n",t,s);            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));            for (i = currentThreadSize; i < s; ++i, ++j)                if(pthread_create(&threadPool[i], NULL, &serverThread, (void*)&idThreads[j]))                {                    sprintf(str, "Error: Creating thread!\n");                    write(STDERR_FILENO,str,strlen(str));                    write(logFd,str,strlen(str));                    exit(EXIT_FAILURE);                }        }        sem_post(&semaphore->semAdditional);    }    for (i = 0; i < s; ++i)        pthread_join(threadPool[i], NULL);    return NULL;}void* serverThread(void* ptr){    char str[4096] = "", c = ' ';    int* id = (int*) ptr, node1 = 0, node2 = 0;    char buff[MAX] = "";    clock_t t = clock();    sprintf(str,"Timestamp(%ld) Thread #%d: waiting for connection\n",t,*id);    write(STDOUT_FILENO,str,strlen(str));    write(logFd,str,strlen(str));    for (;;)    {        sem_wait (&semaphore->semAdditional);        pthread_mutex_lock(&lock);        ++busyThreadCounter;        t = clock();        sprintf(str,"Timestamp(%ld) A connection has been delegated to thread id #%d, system load %.1f%%\n",t,*id,100.0/s);        write(STDOUT_FILENO,str,strlen(str));        write(logFd,str,strlen(str));        bzero(buff, MAX);        int sockfd = dequeue(socketFdQueue);        pthread_mutex_unlock(&lock);        read(sockfd, buff, sizeof(buff));        sscanf(buff,"%d%c%d",&node1,&c,&node2);        bzero(buff, MAX);        t = clock();        sprintf(str,"Timestamp(%ld) Thread #%d: searching database for a path from node %d to node %d\n",t, *id, node1, node2);        write(STDOUT_FILENO,str,strlen(str));        write(logFd,str,strlen(str));        int dbPathSize = 0;        pthread_mutex_lock(&lock);        if(searchInDataBase(node1, node2, &dbPath, &dbPathSize))        {            bzero(buff, MAX);            char temp[4096] = "";            sprintf(buff,"%d",node1);            int i = 0;            for (i = 0; i < dbPathSize; ++i)            {                sprintf(temp, "%s->%d",buff, dbPath[i] );                strcpy(buff, temp);                dbPath[i] = 0;            }            clock_t t1 = clock();            sprintf(str,"Timestamp(%ld) Thread #%d: path found in database: %s\n",t1, *id, buff);            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));        }        else        {            t = clock();            sprintf(str,"Timestamp(%ld) Thread #%d: no path in database, calculating %d->%d\n",t, *id, node1, node2);            write(STDOUT_FILENO,str,strlen(str));            write(logFd,str,strlen(str));            evaluatePathBFS(node1, node2, buff);            clock_t t1 = clock();            if (buff[0] == '#')            {                sprintf(str,"Timestamp(%ld) Thread #%d: path not possible from node %d to %d\n",t1, *id, node1, node2);                write(STDOUT_FILENO,str,strlen(str));                write(logFd,str,strlen(str));            }            else            {                sprintf(str,"Timestamp(%ld) Thread #%d: path calculated: %s\n",t1, *id, buff);                write(STDOUT_FILENO,str,strlen(str));                write(logFd,str,strlen(str));                t1 = clock();                sprintf(str,"Timestamp(%ld) Thread #%d: responding to client and adding path to database\n",t1, *id);                write(STDOUT_FILENO,str,strlen(str));                write(logFd,str,strlen(str));            }        }        --busyThreadCounter;        pthread_mutex_unlock(&lock);        write(sockfd, buff, sizeof(buff));        t = clock() - t;        double time_taken = ((double)t)/CLOCKS_PER_SEC;        write(sockfd, &time_taken, sizeof(double));    }    return NULL;}void evaluatePathBFS(int s, int dest, char* resultPath){    int v = graph->V;    int pred[v], dist[v];    if (BFS(s, dest, pred, dist) == 0)    {        sprintf(resultPath, "###########");        return;    }    struct queue* path = createQueue();    int crawl = dest;    enqueue(path, crawl);    while (pred[crawl] != -1)    {        enqueue(path, pred[crawl]);        crawl = pred[crawl];    }    int pathLength = dist[dest]+1;    int result[pathLength], i = 0;    for (i = 0; i < pathLength; ++i)        result[i] = dequeue(path);    char temp[4096] = "";    sprintf(resultPath, "%d", s);    db->paths[db->rowLength][db->colLengths[db->rowLength]++] = s;    for (i = pathLength-2; i > -1; --i)    {        db->paths[db->rowLength][db->colLengths[db->rowLength]++] = result[i];        sprintf(temp, "%s->%d",resultPath, result[i] );        strcpy(resultPath, temp);    }    ++db->rowLength;    free(path);}int BFS(int src, int dest, int* pred, int* dist){    struct queue* q = createQueue();    int v = graph->V;    int visited[v];    for (int i = 0; i < v; ++i)    {        visited[i] = 0;        dist[i] = 999999;        pred[i] = -1;    }    visited[src] = 1;    dist[src] = 0;    enqueue(q, src);    while (!isEmpty(q))    {        int u = dequeue(q);        struct AdjListNode* i = graph->array[u].head;        for (; i != NULL; i = i->next)        {            if (visited[i->dest] == 0)            {                visited[i->dest] = 1;                dist[i->dest] = dist[u] + 1;                pred[i->dest] = u;                enqueue(q, i->dest);                if (i->dest == dest)                {                    free(q);                    return 1;                }            }        }    }    free(q);    return 0;}int searchInDataBase(int node1, int node2, int** dbPath, int* dbPathSize){    if (db->rowLength == 0)        return 0;    int i = 0, j = 0, k = 0;    for (i = 0; (i < db->rowLength); ++i)        for (j = 0; j < db->colLengths[i]; ++j)            if(db->paths[i][j] == node1)            {                ++j;                k = 0;                for (; j < db->colLengths[i]; ++j)                {                    (*dbPath)[k++] = db->paths[i][j];                    if(db->paths[i][j] == node2)                        break;                }                *dbPathSize = k;                if (j != db->colLengths[i])                    return 1;                break;            }    return 0;}void initSemaphores(){    semaphore = (Semaphore *)mmap(0, sizeof(*semaphore), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);    if (sem_init(&semaphore->semAdditional,1,0) == -1)    {        char str[256] = "";        sprintf(str, "Error: Cannot create semAdditional semaphore!\n");        write(STDERR_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        exit(EXIT_FAILURE);    }    if (sem_init(&semaphore->semServer,1,0) == -1)    {        char str[256] = "";        sprintf(str, "Error: Cannot create semServer semaphore!\n");        write(STDERR_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        exit(EXIT_FAILURE);    }}void destroySemaphores(){    sem_destroy(&semaphore->semAdditional);    sem_destroy(&semaphore->semServer);    if (munmap(semaphore, sizeof(*semaphore)) < 0)    {        perror("Error: munmap semaphore!");        exit(EXIT_FAILURE);    }}void readFile(char* filePath){    int fd = open(filePath, O_RDONLY, 0666);    if (fd == -1)    {        char str[256] = "";        sprintf(str,"Error: Input Open Error Number %d\n", errno);        write(STDERR_FILENO, str, strlen(str));        write(logFd, str, strlen(str));        perror("Program can not open input file!");        exit(EXIT_FAILURE);    }    char c = ' ', nodeSizeString[256] = "", edgeSizeString[256] = "";    char str[256] = "";    int i = 0, nodeSize = 0, edgeSize = 0, node1 = 0, node2 = 0;    clock_t t = clock();    sprintf(str,"Timestamp(%ld) Loading graph...\n", t);    write(STDOUT_FILENO, str, strlen(str));    write(logFd, str, strlen(str));    for(; c != '\n'; read(fd,&c,1));    for(read(fd,&c,1); c != '\n'; read(fd,&c,1));    for(read(fd,&c,1); !isNumber(c); read(fd,&c,1));    for (; isNumber(c); read(fd,&c,1))        nodeSizeString[i++] = c;    nodeSizeString[i] = '\0';    for (; !isNumber(c); read(fd,&c,1));    for (i = 0; isNumber(c); read(fd,&c,1))        edgeSizeString[i++] = c;    edgeSizeString[i] = '\0';    sscanf(nodeSizeString, "%d",&nodeSize );    sscanf(edgeSizeString, "%d",&edgeSize );    read(fd,&c,1);    for(read(fd,&c,1); c != '\n'; read(fd,&c,1));    for(; c != '\n'; read(fd,&c,1));    graph = createGraph(nodeSize);    while(read(fd,&c,1))    {        for(i = 0; c != '\n'; read(fd,&c,1))            nodeSizeString[i++] = c;        nodeSizeString[i] = '\0';        sscanf(nodeSizeString, "%d%c%d",&node1, &c, &node2);        addEdge(graph, node1, node2);    }    close(fd);    t = clock() - t;    double time_taken = ((double)t)/CLOCKS_PER_SEC;    t = clock();    sprintf(str,"Timestamp(%ld) Graph loaded in %.1f seconds with %d nodes and %d edges.\n",t, time_taken, nodeSize, edgeSize);    write(STDOUT_FILENO, str, strlen(str));    write(logFd, str, strlen(str));}int isNumber(char c){    return c <= '9' && c >= '0';}void getArgumentsServer(int argc, char *argv[], char** filePath, int* portNumber, char** logFile){    char str[256] = "";    int opt = 0;    while((opt = getopt(argc, argv, "i:p:o:s:x:")) != -1)    {        switch(opt)        {            case 'i':                *filePath = optarg;                break;            case 'p':                sscanf(optarg,"%d",portNumber);                break;            case 'o':                *logFile = optarg;                break;            case 's':                sscanf(optarg,"%d",&s);                break;            case 'x':                sscanf(optarg,"%d",&x);                break;            default:                perror("Unknown option!");                exit(EXIT_FAILURE);                break;        }    }    sprintf(str,"Executing with parameters:\n-i %s\n-p %d\n-o %s\n-s %d\n-x %d\n", *filePath, *portNumber, *logFile, s, x);    write(STDOUT_FILENO, str, strlen(str));}int makeDaemon(int flags){    int maxfd, fd;    switch (fork())    {        case -1: return -1;        case 0: break;        default: _exit(EXIT_SUCCESS);    }    if (setsid() == -1)        return -1;    switch (fork())    {        case -1: return -1;        case 0: break;        default: _exit(EXIT_SUCCESS);    }    if (!(flags & BD_NO_UMASK0))        umask(0);    if (!(flags & BD_NO_CHDIR))        chdir("/");    if (!(flags & BD_NO_CLOSE_FILES))    {        maxfd = sysconf(_SC_OPEN_MAX);        if (maxfd == -1)        /* Limit is indeterminate... */        maxfd = BD_MAX_CLOSE;        /* so take a guess */        for (fd = 0; fd < maxfd; fd++)            close(fd);    }    if (!(flags & BD_NO_REOPEN_STD_FDS))    {        close(STDIN_FILENO);        /* Reopen standard fd's to /dev/null */        fd = open("/dev/null", O_RDWR);        if (fd != STDIN_FILENO)            return -1;        /* 'fd' should be 0 */        if (dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO)            return -1;        if (dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO)            return -1;    }    return 0;}